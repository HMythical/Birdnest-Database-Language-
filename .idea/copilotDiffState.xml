<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;SQL-Clone-Project-Birdnest-Database-Language&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;version&gt;1.18.30&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;&#10;            &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;&#10;            &lt;version&gt;1.12.8&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;de.mkammerer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;argon2-jvm&lt;/artifactId&gt;&#10;            &lt;version&gt;2.11&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;&#10;            &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;&#10;            &lt;version&gt;1.70&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;SQL-Clone-Project-Birdnest-Database-Language&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;version&gt;1.18.30&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;&#10;            &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;&#10;            &lt;version&gt;1.12.8&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;de.mkammerer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;argon2-jvm&lt;/artifactId&gt;&#10;            &lt;version&gt;2.11&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;&#10;            &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;&#10;            &lt;version&gt;1.70&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Twilio for SMS 2FA --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.twilio.sdk&lt;/groupId&gt;&#10;            &lt;artifactId&gt;twilio&lt;/artifactId&gt;&#10;            &lt;version&gt;9.9.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JWT for auth tokens --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Apache Commons Codec for Base64 encoding --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;commons-codec&lt;/groupId&gt;&#10;            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&#10;            &lt;version&gt;1.15&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/BDLTerminal.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/BDLTerminal.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import javax.swing.text.*;&#10;import java.awt.*;&#10;import java.awt.event.KeyEvent;&#10;import java.awt.event.KeyAdapter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;&#10;public class BDLTerminal extends JFrame {&#10;    private JTextPane outputArea;&#10;    private JTextField inputField;&#10;    private StyledDocument doc;&#10;    private Style defaultStyle;&#10;    private List&lt;String&gt; commandHistory = new ArrayList&lt;&gt;();&#10;    private int historyIndex = -1;&#10;&#10;    private CommandProcessor commandProcessor;&#10;    private Set&lt;String&gt; keywords;&#10;    private Style keywordStyle;&#10;    private Style stringStyle;&#10;    private Style numberStyle;&#10;&#10;    public BDLTerminal() {&#10;        // Initialize CommandProcessor with UserDatabase&#10;        UserDatabase userDatabase = new UserDatabase();&#10;        commandProcessor = new CommandProcessor(userDatabase);&#10;&#10;        // Create initial admin user&#10;        User adminUser = new User(&#10;            &quot;admin&quot;,&#10;            &quot;admin&quot;,  // Should be changed on first login&#10;            &quot;localhost&quot;,&#10;            new String[]{&quot;ADMIN+&quot;},&#10;            false,&#10;            LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),&#10;            &quot;SYSTEM&quot;&#10;        );&#10;        userDatabase.addUser(adminUser);&#10;        commandProcessor.setCurrentUser(adminUser);&#10;&#10;        initializeKeywords();&#10;        setupStyles();&#10;&#10;        setTitle(&quot;BDL Terminal&quot;);&#10;        setSize(800, 600);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;&#10;        outputArea = new JTextPane();&#10;        outputArea.setEditable(false);&#10;        outputArea.setBackground(Color.BLACK);&#10;        outputArea.setForeground(Color.GREEN);&#10;        outputArea.setFont(new Font(&quot;Consolas&quot;, Font.PLAIN, 14));&#10;&#10;        doc = outputArea.getStyledDocument();&#10;        defaultStyle = StyleContext.getDefaultStyleContext().getStyle(StyleContext.DEFAULT_STYLE);&#10;&#10;        inputField = new JTextField();&#10;        inputField.setBackground(Color.BLACK);&#10;        inputField.setForeground(Color.GREEN);&#10;        inputField.setFont(new Font(&quot;Consolas&quot;, Font.PLAIN, 14));&#10;        inputField.setCaretColor(Color.GREEN);&#10;&#10;        setLayout(new BorderLayout());&#10;        add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;        add(inputField, BorderLayout.SOUTH);&#10;&#10;        inputField.addKeyListener(new KeyAdapter() {&#10;            @Override&#10;            public void keyPressed(KeyEvent e) {&#10;                if (e.getKeyCode() == KeyEvent.VK_ENTER) {&#10;                    String command = inputField.getText().trim();&#10;                    if (!command.isEmpty()) {&#10;                        commandHistory.add(command);&#10;                        historyIndex = commandHistory.size();&#10;                        appendOutput(&quot;&gt; &quot; + command + &quot;\n&quot;);&#10;&#10;                        // Process command and display result&#10;                        String result = commandProcessor.processCommand(command);&#10;                        appendOutput(result + &quot;\n&quot;);&#10;&#10;                        inputField.setText(&quot;&quot;);&#10;                    }&#10;                    SwingUtilities.invokeLater(() -&gt; highlightSyntax());&#10;                } else if (e.getKeyCode() == KeyEvent.VK_UP) {&#10;                    if (!commandHistory.isEmpty()) {&#10;                        if (historyIndex &gt; 0) historyIndex--;&#10;                        inputField.setText(commandHistory.get(historyIndex));&#10;                    }&#10;                } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {&#10;                    if (!commandHistory.isEmpty() &amp;&amp; historyIndex &lt; commandHistory.size() - 1) {&#10;                        historyIndex++;&#10;                        inputField.setText(commandHistory.get(historyIndex));&#10;                    } else {&#10;                        inputField.setText(&quot;&quot;);&#10;                        historyIndex = commandHistory.size();&#10;                    }&#10;                } else {&#10;                    SwingUtilities.invokeLater(() -&gt; highlightSyntax());&#10;                }&#10;            }&#10;        });&#10;&#10;        appendOutput(&quot;BDL Terminal - Ready\n&quot;);&#10;    }&#10;&#10;    private void initializeKeywords() {&#10;        keywords = new HashSet&lt;&gt;(Arrays.asList(&#10;            &quot;HATCH&quot;, &quot;DROP&quot;, &quot;GRANT&quot;, &quot;REVOKE&quot;, &quot;CREATE&quot;, &quot;ROLE&quot;, &quot;CHICK&quot;, &quot;NEW&quot;,&#10;            &quot;PERMISSION&quot;, &quot;TO&quot;, &quot;DURATION&quot;, &quot;FROM&quot;, &quot;PICK&quot;, &quot;EGG&quot;, &quot;NEST&quot;, &quot;LAY&quot;,&#10;            &quot;INTO&quot;, &quot;UPDATE&quot;, &quot;SET&quot;, &quot;WHILE&quot;, &quot;REMOVE&quot;, &quot;DESTROY&quot;, &quot;EXPORT&quot;, &quot;GRAPH&quot;&#10;        ));&#10;    }&#10;&#10;    private void setupStyles() {&#10;        StyleContext styleContext = StyleContext.getDefaultStyleContext();&#10;&#10;        defaultStyle = styleContext.addStyle(&quot;default&quot;, null);&#10;        StyleConstants.setForeground(defaultStyle, Color.BLUE);&#10;&#10;        keywordStyle = styleContext.addStyle(&quot;keyword&quot;, null);&#10;        StyleConstants.setForeground(keywordStyle, Color.CYAN);&#10;        StyleConstants.setBold(keywordStyle, true);&#10;&#10;        stringStyle = styleContext.addStyle(&quot;string&quot;, null);&#10;        StyleConstants.setForeground(stringStyle, Color.ORANGE);&#10;&#10;        numberStyle = styleContext.addStyle(&quot;number&quot;, null);&#10;        StyleConstants.setForeground(numberStyle, Color.YELLOW);&#10;    }&#10;&#10;    private void appendOutput(String text) {&#10;        try {&#10;            // Apply syntax highlighting to output&#10;            if (text.startsWith(&quot;&gt;&quot;)) {&#10;                // Command echo gets blue color&#10;                doc.insertString(doc.getLength(), text, defaultStyle);&#10;            } else {&#10;                // Response gets default green color&#10;                SimpleAttributeSet style = new SimpleAttributeSet();&#10;                StyleConstants.setForeground(style, Color.GREEN);&#10;                doc.insertString(doc.getLength(), text, style);&#10;            }&#10;            outputArea.setCaretPosition(doc.getLength());&#10;        } catch (BadLocationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void highlightSyntax() {&#10;        String text = inputField.getText();&#10;        DefaultStyledDocument doc = new DefaultStyledDocument();&#10;        try {&#10;            // Set default blue color for input&#10;            SimpleAttributeSet defaultInputStyle = new SimpleAttributeSet();&#10;            StyleConstants.setForeground(defaultInputStyle, Color.BLUE);&#10;            doc.insertString(0, text, defaultInputStyle);&#10;&#10;            // Highlight keywords and other elements&#10;            String[] tokens = text.split(&quot;\\s+&quot;);&#10;            int pos = 0;&#10;            for (String token : tokens) {&#10;                pos = text.indexOf(token, pos);&#10;                if (pos == -1) continue;&#10;&#10;                if (keywords.contains(token.toUpperCase())) {&#10;                    doc.setCharacterAttributes(pos, token.length(), keywordStyle, true);&#10;                } else if (token.matches(&quot;'.*'&quot;)) {&#10;                    doc.setCharacterAttributes(pos, token.length(), stringStyle, true);&#10;                } else if (token.matches(&quot;\\d+&quot;)) {&#10;                    doc.setCharacterAttributes(pos, token.length(), numberStyle, true);&#10;                } else {&#10;                    doc.setCharacterAttributes(pos, token.length(), defaultInputStyle, true);&#10;                }&#10;                pos += token.length();&#10;            }&#10;        } catch (BadLocationException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;        inputField.setDocument(doc);&#10;        inputField.setCaretPosition(text.length());&#10;    }&#10;&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BDLTerminal terminal = new BDLTerminal();&#10;            terminal.setVisible(true);&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import javax.swing.text.*;&#10;import java.awt.*;&#10;import java.awt.event.KeyEvent;&#10;import java.awt.event.KeyAdapter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Arrays;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;&#10;public class BDLTerminal extends JFrame {&#10;    private JTextPane outputArea;&#10;    private JTextField inputField;&#10;    private StyledDocument doc;&#10;    private Style defaultStyle;&#10;    private List&lt;String&gt; commandHistory = new ArrayList&lt;&gt;();&#10;    private int historyIndex = -1;&#10;&#10;    private CommandProcessor commandProcessor;&#10;    private Set&lt;String&gt; keywords;&#10;    private Style keywordStyle;&#10;    private Style stringStyle;&#10;    private Style numberStyle;&#10;&#10;    public BDLTerminal() {&#10;        // Initialize CommandProcessor with UserDatabase&#10;        UserDatabase userDatabase = new UserDatabase();&#10;        commandProcessor = new CommandProcessor(userDatabase);&#10;&#10;        // Create initial admin user&#10;        User adminUser = new User(&#10;            &quot;admin&quot;,&#10;            &quot;admin&quot;,  // Should be changed on first login&#10;            &quot;localhost&quot;,&#10;            new String[]{&quot;ADMIN+&quot;},&#10;            false,&#10;            LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),&#10;            &quot;SYSTEM&quot;&#10;        );&#10;        userDatabase.addUser(adminUser);&#10;        commandProcessor.setCurrentUser(adminUser);&#10;&#10;        initializeKeywords();&#10;        setupStyles();&#10;&#10;        setTitle(&quot;BDL Terminal&quot;);&#10;        setSize(800, 600);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;&#10;        outputArea = new JTextPane();&#10;        outputArea.setEditable(false);&#10;        outputArea.setBackground(Color.BLACK);&#10;        outputArea.setForeground(Color.GREEN);&#10;        outputArea.setFont(new Font(&quot;Consolas&quot;, Font.PLAIN, 14));&#10;&#10;        doc = outputArea.getStyledDocument();&#10;        defaultStyle = StyleContext.getDefaultStyleContext().getStyle(StyleContext.DEFAULT_STYLE);&#10;&#10;        inputField = new JTextField();&#10;        inputField.setBackground(Color.BLACK);&#10;        inputField.setForeground(Color.GREEN);&#10;        inputField.setFont(new Font(&quot;Consolas&quot;, Font.PLAIN, 14));&#10;        inputField.setCaretColor(Color.GREEN);&#10;&#10;        setLayout(new BorderLayout());&#10;        add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;        add(inputField, BorderLayout.SOUTH);&#10;&#10;        inputField.addKeyListener(new KeyAdapter() {&#10;            @Override&#10;            public void keyPressed(KeyEvent e) {&#10;                if (e.getKeyCode() == KeyEvent.VK_ENTER) {&#10;                    String command = inputField.getText().trim();&#10;                    if (!command.isEmpty()) {&#10;                        commandHistory.add(command);&#10;                        historyIndex = commandHistory.size();&#10;                        appendOutput(&quot;&gt; &quot; + command + &quot;\n&quot;);&#10;&#10;                        // Process command and display result&#10;                        String result = commandProcessor.processCommand(command);&#10;                        appendOutput(result + &quot;\n&quot;);&#10;&#10;                        inputField.setText(&quot;&quot;);&#10;                    }&#10;                    SwingUtilities.invokeLater(() -&gt; highlightSyntax());&#10;                } else if (e.getKeyCode() == KeyEvent.VK_UP) {&#10;                    if (!commandHistory.isEmpty()) {&#10;                        if (historyIndex &gt; 0) historyIndex--;&#10;                        inputField.setText(commandHistory.get(historyIndex));&#10;                    }&#10;                } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {&#10;                    if (!commandHistory.isEmpty() &amp;&amp; historyIndex &lt; commandHistory.size() - 1) {&#10;                        historyIndex++;&#10;                        inputField.setText(commandHistory.get(historyIndex));&#10;                    } else {&#10;                        inputField.setText(&quot;&quot;);&#10;                        historyIndex = commandHistory.size();&#10;                    }&#10;                } else {&#10;                    SwingUtilities.invokeLater(() -&gt; highlightSyntax());&#10;                }&#10;            }&#10;        });&#10;&#10;        appendOutput(&quot;BDL Terminal - Ready\n&quot;);&#10;    }&#10;&#10;    private void initializeKeywords() {&#10;        keywords = new HashSet&lt;&gt;(Arrays.asList(&#10;            &quot;HATCH&quot;, &quot;DROP&quot;, &quot;GRANT&quot;, &quot;REVOKE&quot;, &quot;CREATE&quot;, &quot;ROLE&quot;, &quot;CHICK&quot;, &quot;NEW&quot;,&#10;            &quot;PERMISSION&quot;, &quot;TO&quot;, &quot;DURATION&quot;, &quot;FROM&quot;, &quot;PICK&quot;, &quot;EGG&quot;, &quot;NEST&quot;, &quot;LAY&quot;,&#10;            &quot;INTO&quot;, &quot;UPDATE&quot;, &quot;SET&quot;, &quot;WHILE&quot;, &quot;REMOVE&quot;, &quot;DESTROY&quot;, &quot;EXPORT&quot;, &quot;GRAPH&quot;&#10;        ));&#10;    }&#10;&#10;    private void setupStyles() {&#10;        StyleContext styleContext = StyleContext.getDefaultStyleContext();&#10;&#10;        defaultStyle = styleContext.addStyle(&quot;default&quot;, null);&#10;        StyleConstants.setForeground(defaultStyle, Color.BLUE);&#10;&#10;        keywordStyle = styleContext.addStyle(&quot;keyword&quot;, null);&#10;        StyleConstants.setForeground(keywordStyle, Color.CYAN);&#10;        StyleConstants.setBold(keywordStyle, true);&#10;&#10;        stringStyle = styleContext.addStyle(&quot;string&quot;, null);&#10;        StyleConstants.setForeground(stringStyle, Color.ORANGE);&#10;&#10;        numberStyle = styleContext.addStyle(&quot;number&quot;, null);&#10;        StyleConstants.setForeground(numberStyle, Color.YELLOW);&#10;    }&#10;&#10;    private void appendOutput(String text) {&#10;        try {&#10;            // Apply syntax highlighting to output&#10;            if (text.startsWith(&quot;&gt;&quot;)) {&#10;                // Command echo gets blue color&#10;                SimpleAttributeSet commandStyle = new SimpleAttributeSet();&#10;                StyleConstants.setForeground(commandStyle, Color.BLUE);&#10;                doc.insertString(doc.getLength(), text, commandStyle);&#10;            } else if (text.contains(&quot;Error:&quot;) || text.contains(&quot;FAULTYPERMISSION&quot;)) {&#10;                // Errors in red&#10;                SimpleAttributeSet errorStyle = new SimpleAttributeSet();&#10;                StyleConstants.setForeground(errorStyle, Color.RED);&#10;                doc.insertString(doc.getLength(), text, errorStyle);&#10;            } else if (text.contains(&quot;Successfully&quot;)) {&#10;                // Success messages in bright green&#10;                SimpleAttributeSet successStyle = new SimpleAttributeSet();&#10;                StyleConstants.setForeground(successStyle, new Color(0, 255, 0));&#10;                doc.insertString(doc.getLength(), text, successStyle);&#10;            } else {&#10;                // Response gets default green color&#10;                SimpleAttributeSet style = new SimpleAttributeSet();&#10;                StyleConstants.setForeground(style, Color.GREEN);&#10;                doc.insertString(doc.getLength(), text, style);&#10;            }&#10;            outputArea.setCaretPosition(doc.getLength());&#10;        } catch (BadLocationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private void highlightSyntax() {&#10;        String text = inputField.getText();&#10;        DefaultStyledDocument doc = new DefaultStyledDocument();&#10;        try {&#10;            // Set default white color for input&#10;            SimpleAttributeSet defaultInputStyle = new SimpleAttributeSet();&#10;            StyleConstants.setForeground(defaultInputStyle, Color.WHITE);&#10;            doc.insertString(0, text, defaultInputStyle);&#10;&#10;            // Split by spaces but preserve strings in single quotes&#10;            List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#10;            StringBuilder currentToken = new StringBuilder();&#10;            boolean inQuotes = false;&#10;            &#10;            for (char c : text.toCharArray()) {&#10;                if (c == '\'') {&#10;                    inQuotes = !inQuotes;&#10;                    currentToken.append(c);&#10;                } else if (c == ' ' &amp;&amp; !inQuotes) {&#10;                    if (currentToken.length() &gt; 0) {&#10;                        tokens.add(currentToken.toString());&#10;                        currentToken = new StringBuilder();&#10;                    }&#10;                } else {&#10;                    currentToken.append(c);&#10;                }&#10;            }&#10;            if (currentToken.length() &gt; 0) {&#10;                tokens.add(currentToken.toString());&#10;            }&#10;&#10;            // Highlight tokens&#10;            int pos = 0;&#10;            for (String token : tokens) {&#10;                pos = text.indexOf(token, pos);&#10;                if (pos == -1) continue;&#10;&#10;                if (keywords.contains(token.toUpperCase())) {&#10;                    doc.setCharacterAttributes(pos, token.length(), keywordStyle, true);&#10;                } else if (token.matches(&quot;'.*'&quot;)) {&#10;                    doc.setCharacterAttributes(pos, token.length(), stringStyle, true);&#10;                } else if (token.matches(&quot;\\d+&quot;)) {&#10;                    doc.setCharacterAttributes(pos, token.length(), numberStyle, true);&#10;                } else if (token.contains(&quot;@&quot;)) {&#10;                    doc.setCharacterAttributes(pos, token.length(), stringStyle, true);&#10;                } else {&#10;                    doc.setCharacterAttributes(pos, token.length(), defaultInputStyle, true);&#10;                }&#10;                pos += token.length();&#10;            }&#10;        } catch (BadLocationException e) {&#10;            e.printStackTrace();&#10;        }&#10;&#10;        inputField.setDocument(doc);&#10;        inputField.setCaretPosition(text.length());&#10;    }&#10;&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BDLTerminal terminal = new BDLTerminal();&#10;            terminal.setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/CommandProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/CommandProcessor.java" />
              <option name="originalContent" value="import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Timer;&#10;import java.util.TimerTask;&#10;&#10;public class CommandProcessor {&#10;    private UserDatabase userDatabase;&#10;    private User currentUser;&#10;    private Timer debugTimer;&#10;&#10;    public CommandProcessor(UserDatabase userDatabase) {&#10;        this.userDatabase = userDatabase;&#10;        this.debugTimer = new Timer(true); // Create daemon timer&#10;    }&#10;&#10;    public void setCurrentUser(User user) {&#10;        this.currentUser = user;&#10;    }&#10;&#10;    public String processCommand(String command) {&#10;        if (command == null || command.trim().isEmpty()) {&#10;            return &quot;Error: Empty command&quot;;&#10;        }&#10;&#10;        List&lt;String&gt; tokens = parseCommand(command);&#10;        if (tokens.isEmpty()) {&#10;            return &quot;Error: Invalid command format&quot;;&#10;        }&#10;&#10;        try {&#10;            // Convert List to array for compatibility with existing code&#10;            String[] tokenArray = tokens.toArray(new String[0]);&#10;&#10;            // Validate token format&#10;            validateTokens(tokenArray);&#10;&#10;            switch (tokenArray[0].toUpperCase()) {&#10;                case &quot;HATCH&quot;:&#10;                    return processHatchCommand(tokenArray);&#10;                case &quot;DROP&quot;:&#10;                    return processDropCommand(tokenArray);&#10;                case &quot;GRANT&quot;:&#10;                    return processGrantCommand(tokenArray);&#10;                case &quot;REVOKE&quot;:&#10;                    return processRevokeCommand(tokenArray);&#10;                case &quot;CREATE&quot;:&#10;                    if (tokenArray[1].equalsIgnoreCase(&quot;ROLE&quot;)) {&#10;                        return processCreateRoleCommand(tokenArray);&#10;                    }&#10;                case &quot;INIT&quot;:&#10;                    if (tokenArray[1].equalsIgnoreCase(&quot;DEBUG&quot;)) {&#10;                        return processDebugCommand(tokenArray);&#10;                    }&#10;                default:&#10;                    return &quot;Unknown command&quot;;&#10;            }&#10;        } catch (Exception e) {&#10;            return &quot;Error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    private List&lt;String&gt; parseCommand(String command) {&#10;        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#10;        StringBuilder currentToken = new StringBuilder();&#10;        boolean inQuotes = false;&#10;&#10;        for (int i = 0; i &lt; command.length(); i++) {&#10;            char c = command.charAt(i);&#10;&#10;            if (c == '\'') {&#10;                inQuotes = !inQuotes;&#10;                currentToken.append(c);&#10;            } else if (c == ' ' &amp;&amp; !inQuotes) {&#10;                if (currentToken.length() &gt; 0) {&#10;                    tokens.add(currentToken.toString());&#10;                    currentToken = new StringBuilder();&#10;                }&#10;            } else {&#10;                currentToken.append(c);&#10;            }&#10;        }&#10;&#10;        if (currentToken.length() &gt; 0) {&#10;            tokens.add(currentToken.toString());&#10;        }&#10;&#10;        return tokens;&#10;    }&#10;&#10;    private void validateTokens(String[] tokens) {&#10;        String command = tokens[0].toUpperCase();&#10;&#10;        switch (command) {&#10;            case &quot;HATCH&quot;:&#10;                if (tokens.length != 6) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command format. Expected: HATCH NEW CHICK 'username'@'host' RECOGNITION 'auth_type'&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;NEW&quot;) || !tokens[2].equalsIgnoreCase(&quot;CHICK&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command syntax&quot;);&#10;                }&#10;                // Validate username@host format&#10;                String userHost = tokens[3];&#10;                if (!userHost.contains(&quot;@&quot;) || !userHost.startsWith(&quot;'&quot;) || !userHost.contains(&quot;'@'&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid username@host format. Expected: 'username'@'host'&quot;);&#10;                }&#10;                if (!tokens[4].equalsIgnoreCase(&quot;RECOGNITION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command syntax: Expected RECOGNITION keyword&quot;);&#10;                }&#10;                if (!tokens[5].startsWith(&quot;'&quot;) || !tokens[5].endsWith(&quot;'&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid auth_type format. Expected: 'auth_type'&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;DROP&quot;:&#10;                if (tokens.length &lt; 3) {&#10;                    throw new IllegalArgumentException(&quot;Invalid DROP command format. Expected: DROP CHICK 'username' ['reason']&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;CHICK&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid DROP command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;GRANT&quot;:&#10;                if (tokens.length &lt; 9) {&#10;                    throw new IllegalArgumentException(&quot;Invalid GRANT command format. Expected: GRANT CHICK username PERMISSION permission_type TO nest DURATION duration&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;CHICK&quot;) || !tokens[3].equalsIgnoreCase(&quot;PERMISSION&quot;) ||&#10;                    !tokens[5].equalsIgnoreCase(&quot;TO&quot;) || !tokens[7].equalsIgnoreCase(&quot;DURATION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid GRANT command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;REVOKE&quot;:&#10;                if (tokens.length &lt; 7) {&#10;                    throw new IllegalArgumentException(&quot;Invalid REVOKE command format. Expected: REVOKE PERMISSION permission_type FROM 'username' DURATION duration&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;PERMISSION&quot;) || !tokens[3].equalsIgnoreCase(&quot;FROM&quot;) ||&#10;                    !tokens[5].equalsIgnoreCase(&quot;DURATION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid REVOKE command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;CREATE&quot;:&#10;                if (tokens.length &lt; 4 || !tokens[1].equalsIgnoreCase(&quot;ROLE&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid CREATE ROLE command format. Expected: CREATE ROLE 'role_name' hierarchy_number&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;INIT&quot;:&#10;                if (tokens.length &lt; 3 || !tokens[1].equalsIgnoreCase(&quot;DEBUG&quot;) || !tokens[2].equalsIgnoreCase(&quot;USER&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid INIT DEBUG command format. Expected: INIT DEBUG USER [timeLength]&quot;);&#10;                }&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unknown command: &quot; + command);&#10;        }&#10;    }&#10;&#10;    private String processHatchCommand(String[] tokens) {&#10;        // Format: HATCH NEW CHICK 'username'@'host' RECOGNITION 'auth_type'&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String userHost = tokens[3];&#10;        int atIndex = userHost.indexOf(&quot;@&quot;);&#10;        if (atIndex == -1) {&#10;            throw new IllegalArgumentException(&quot;Invalid username@host format&quot;);&#10;        }&#10;&#10;        // Extract username and host, handling the quotes properly&#10;        String username = userHost.substring(1, userHost.indexOf(&quot;'@'&quot;));&#10;        String host = userHost.substring(userHost.indexOf(&quot;'@'&quot;) + 2, userHost.length() - 1);&#10;        String authType = tokens[5].substring(1, tokens[5].length() - 1);&#10;&#10;        // Validate the user doesn't already exist&#10;        if (userDatabase.getUser(username) != null) {&#10;            throw new IllegalArgumentException(&quot;User already exists: &quot; + username);&#10;        }&#10;&#10;        User newUser = new User(&#10;            username,&#10;            generateTempPassword(),&#10;            host,&#10;            new String[]{&quot;BASE_USER&quot;},&#10;            false,&#10;            LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),&#10;            currentUser.getUsername()&#10;        );&#10;&#10;        userDatabase.addUser(newUser);&#10;        return &quot;Successfully created new user: &quot; + username + &quot; with host: &quot; + host;&#10;    }&#10;&#10;    private String processDropCommand(String[] tokens) {&#10;        // Format: DROP CHICK 'username' ['reason']&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String username = tokens[2].replace(&quot;'&quot;, &quot;&quot;);&#10;        if (!userDatabase.getUsers().containsKey(username)) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        userDatabase.removeUser(username);&#10;        return &quot;Successfully dropped user: &quot; + username;&#10;    }&#10;&#10;    private String processGrantCommand(String[] tokens) {&#10;        // Format: GRANT CHICK username PERMISSION permission_type TO nest DURATION duration&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String username = tokens[2];&#10;        String permissionType = tokens[4];&#10;        String targetNest = tokens[6];&#10;        int duration = parseDuration(tokens[8]);&#10;&#10;        User user = userDatabase.getUser(username);&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        String[] currentPermissions = user.getPermissions();&#10;        String[] newPermissions = Arrays.copyOf(currentPermissions, currentPermissions.length + 1);&#10;        newPermissions[currentPermissions.length] = permissionType;&#10;&#10;        userDatabase.modifyPermissions(username, newPermissions);&#10;        return &quot;Successfully granted &quot; + permissionType + &quot; to &quot; + username;&#10;    }&#10;&#10;    private String processRevokeCommand(String[] tokens) {&#10;        // Format: REVOKE PERMISSION permission_type FROM 'username' DURATION duration&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String permissionType = tokens[2];&#10;        String username = tokens[4].replace(&quot;'&quot;, &quot;&quot;);&#10;        int duration = parseDuration(tokens[6]);&#10;&#10;        User user = userDatabase.getUser(username);&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        String[] currentPermissions = user.getPermissions();&#10;        String[] newPermissions = Arrays.stream(currentPermissions)&#10;            .filter(p -&gt; !p.equals(permissionType))&#10;            .toArray(String[]::new);&#10;&#10;        userDatabase.modifyPermissions(username, newPermissions);&#10;        return &quot;Successfully revoked &quot; + permissionType + &quot; from &quot; + username;&#10;    }&#10;&#10;    private String processCreateRoleCommand(String[] tokens) {&#10;        // Format: CREATE ROLE 'role_name' hierarchy_number&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String roleName = tokens[2].replace(&quot;'&quot;, &quot;&quot;);&#10;        int hierarchyLevel = Integer.parseInt(tokens[3]);&#10;&#10;        // Add role to database (you might want to extend UserDatabase to handle roles)&#10;        return &quot;Successfully created role: &quot; + roleName + &quot; with hierarchy level &quot; + hierarchyLevel;&#10;    }&#10;&#10;    private String processDebugCommand(String[] tokens) {&#10;        // Format: INIT DEBUG USER [timeLength]&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        int timeLength = tokens.length &gt; 3 ? Integer.parseInt(tokens[3]) : 60; // Default 60 seconds&#10;        debugTimer.schedule(new TimerTask() {&#10;            @Override&#10;            public void run() {&#10;                System.out.println(&quot;Debug session ended for user: &quot; + currentUser.getUsername());&#10;            }&#10;        }, timeLength * 1000L);&#10;&#10;        return &quot;Debug mode initialized for &quot; + timeLength + &quot; seconds&quot;;&#10;    }&#10;&#10;    private boolean hasAdminPermissions() {&#10;        if (currentUser == null) return false;&#10;        return Arrays.asList(currentUser.getPermissions()).contains(&quot;ADMIN+&quot;);&#10;    }&#10;&#10;    private String generateTempPassword() {&#10;        // Generate a random 12-character password&#10;        String chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*&quot;;&#10;        StringBuilder password = new StringBuilder();&#10;        for (int i = 0; i &lt; 12; i++) {&#10;            password.append(chars.charAt((int) (Math.random() * chars.length())));&#10;        }&#10;        return password.toString();&#10;    }&#10;&#10;    private int parseDuration(String duration) {&#10;        try {&#10;            return Integer.parseInt(duration);&#10;        } catch (NumberFormatException e) {&#10;            throw new IllegalArgumentException(&quot;Invalid duration format. Expected a number.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Timer;&#10;import java.util.TimerTask;&#10;&#10;public class CommandProcessor {&#10;    private UserDatabase userDatabase;&#10;    private User currentUser;&#10;    private Timer debugTimer;&#10;    private Encryptor encryptor = new Encryptor();&#10;&#10;    public CommandProcessor(UserDatabase userDatabase) {&#10;        this.userDatabase = userDatabase;&#10;        this.debugTimer = new Timer(true); // Create daemon timer&#10;    }&#10;&#10;    public void setCurrentUser(User user) {&#10;        this.currentUser = user;&#10;    }&#10;&#10;    public String processCommand(String command) {&#10;        if (command == null || command.trim().isEmpty()) {&#10;            return &quot;Error: Empty command&quot;;&#10;        }&#10;&#10;        List&lt;String&gt; tokens = parseCommand(command);&#10;        if (tokens.isEmpty()) {&#10;            return &quot;Error: Invalid command format&quot;;&#10;        }&#10;&#10;        try {&#10;            // Convert List to array for compatibility with existing code&#10;            String[] tokenArray = tokens.toArray(new String[0]);&#10;&#10;            // Validate token format&#10;            validateTokens(tokenArray);&#10;&#10;            switch (tokenArray[0].toUpperCase()) {&#10;                case &quot;HATCH&quot;:&#10;                    return processHatchCommand(tokenArray);&#10;                case &quot;DROP&quot;:&#10;                    return processDropCommand(tokenArray);&#10;                case &quot;GRANT&quot;:&#10;                    return processGrantCommand(tokenArray);&#10;                case &quot;REVOKE&quot;:&#10;                    return processRevokeCommand(tokenArray);&#10;                case &quot;CREATE&quot;:&#10;                    if (tokenArray[1].equalsIgnoreCase(&quot;ROLE&quot;)) {&#10;                        return processCreateRoleCommand(tokenArray);&#10;                    }&#10;                case &quot;INIT&quot;:&#10;                    if (tokenArray[1].equalsIgnoreCase(&quot;DEBUG&quot;)) {&#10;                        return processDebugCommand(tokenArray);&#10;                    }&#10;                default:&#10;                    return &quot;Unknown command&quot;;&#10;            }&#10;        } catch (Exception e) {&#10;            return &quot;Error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    private List&lt;String&gt; parseCommand(String command) {&#10;        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#10;        StringBuilder currentToken = new StringBuilder();&#10;        boolean inQuotes = false;&#10;&#10;        for (int i = 0; i &lt; command.length(); i++) {&#10;            char c = command.charAt(i);&#10;&#10;            if (c == '\'') {&#10;                inQuotes = !inQuotes;&#10;                currentToken.append(c);&#10;            } else if (c == ' ' &amp;&amp; !inQuotes) {&#10;                if (currentToken.length() &gt; 0) {&#10;                    tokens.add(currentToken.toString());&#10;                    currentToken = new StringBuilder();&#10;                }&#10;            } else {&#10;                currentToken.append(c);&#10;            }&#10;        }&#10;&#10;        if (currentToken.length() &gt; 0) {&#10;            tokens.add(currentToken.toString());&#10;        }&#10;&#10;        return tokens;&#10;    }&#10;&#10;    private void validateTokens(String[] tokens) {&#10;        String command = tokens[0].toUpperCase();&#10;&#10;        switch (command) {&#10;            case &quot;HATCH&quot;:&#10;                if (tokens.length != 6) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command format. Expected: HATCH NEW CHICK 'username'@'host' RECOGNITION 'auth_type'&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;NEW&quot;) || !tokens[2].equalsIgnoreCase(&quot;CHICK&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command syntax&quot;);&#10;                }&#10;                // Validate username@host format&#10;                String userHost = tokens[3];&#10;                if (!userHost.contains(&quot;@&quot;) || !userHost.startsWith(&quot;'&quot;) || !userHost.contains(&quot;'@'&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid username@host format. Expected: 'username'@'host'&quot;);&#10;                }&#10;                if (!tokens[4].equalsIgnoreCase(&quot;RECOGNITION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid HATCH command syntax: Expected RECOGNITION keyword&quot;);&#10;                }&#10;                if (!tokens[5].startsWith(&quot;'&quot;) || !tokens[5].endsWith(&quot;'&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid auth_type format. Expected: 'auth_type'&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;DROP&quot;:&#10;                if (tokens.length &lt; 3) {&#10;                    throw new IllegalArgumentException(&quot;Invalid DROP command format. Expected: DROP CHICK 'username' ['reason']&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;CHICK&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid DROP command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;GRANT&quot;:&#10;                if (tokens.length &lt; 9) {&#10;                    throw new IllegalArgumentException(&quot;Invalid GRANT command format. Expected: GRANT CHICK username PERMISSION permission_type TO nest DURATION duration&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;CHICK&quot;) || !tokens[3].equalsIgnoreCase(&quot;PERMISSION&quot;) ||&#10;                    !tokens[5].equalsIgnoreCase(&quot;TO&quot;) || !tokens[7].equalsIgnoreCase(&quot;DURATION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid GRANT command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;REVOKE&quot;:&#10;                if (tokens.length &lt; 7) {&#10;                    throw new IllegalArgumentException(&quot;Invalid REVOKE command format. Expected: REVOKE PERMISSION permission_type FROM 'username' DURATION duration&quot;);&#10;                }&#10;                if (!tokens[1].equalsIgnoreCase(&quot;PERMISSION&quot;) || !tokens[3].equalsIgnoreCase(&quot;FROM&quot;) ||&#10;                    !tokens[5].equalsIgnoreCase(&quot;DURATION&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid REVOKE command syntax&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;CREATE&quot;:&#10;                if (tokens.length &lt; 4 || !tokens[1].equalsIgnoreCase(&quot;ROLE&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid CREATE ROLE command format. Expected: CREATE ROLE 'role_name' hierarchy_number&quot;);&#10;                }&#10;                break;&#10;&#10;            case &quot;INIT&quot;:&#10;                if (tokens.length &lt; 3 || !tokens[1].equalsIgnoreCase(&quot;DEBUG&quot;) || !tokens[2].equalsIgnoreCase(&quot;USER&quot;)) {&#10;                    throw new IllegalArgumentException(&quot;Invalid INIT DEBUG command format. Expected: INIT DEBUG USER [timeLength]&quot;);&#10;                }&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unknown command: &quot; + command);&#10;        }&#10;    }&#10;&#10;    private String processHatchCommand(String[] tokens) {&#10;        // Format: HATCH NEW CHICK 'username'@'host' RECOGNITION 'auth_type'&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String userHost = tokens[3];&#10;        String username = userHost.substring(1, userHost.indexOf(&quot;'@'&quot;));&#10;        String host = userHost.substring(userHost.indexOf(&quot;'@'&quot;) + 2, userHost.length() - 1);&#10;        String authType = tokens[5].substring(1, tokens[5].length() - 1).toLowerCase();&#10;&#10;        // Validate the user doesn't already exist&#10;        if (userDatabase.getUser(username) != null) {&#10;            throw new IllegalArgumentException(&quot;User already exists: &quot; + username);&#10;        }&#10;&#10;        String password = null;&#10;        String authKey = null;&#10;        String phoneNumber = null;&#10;&#10;        switch (authType) {&#10;            case &quot;password&quot;:&#10;                // Generate a temporary password that the user must change on first login&#10;                password = encryptor.hashPassword(generateTempPassword());&#10;                break;&#10;&#10;            case &quot;auth_key&quot;:&#10;                // Generate an auth key for the user&#10;                authKey = encryptor.generateAuthKey();&#10;                break;&#10;&#10;            case &quot;2fa&quot;:&#10;                // For 2FA, we need to:&#10;                // 1. Generate a temporary password&#10;                // 2. Get the user's phone number (this would typically be done through UI interaction)&#10;                // 3. Send verification code&#10;                password = encryptor.hashPassword(generateTempPassword());&#10;                // Note: In a real implementation, you would need to prompt for the phone number&#10;                // and handle the verification process through the UI&#10;                phoneNumber = &quot;+1234567890&quot;; // This should come from user input&#10;                String verificationCode = encryptor.initiate2FA(phoneNumber);&#10;                // In a real implementation, you would wait for the user to enter the code&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Invalid authentication type. Expected: password, auth_key, or 2fa&quot;);&#10;        }&#10;&#10;        User newUser = new User(&#10;            username,&#10;            password,&#10;            host,&#10;            new String[]{&quot;BASE_USER&quot;},&#10;            false,&#10;            LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),&#10;            currentUser.getUsername(),&#10;            authType,&#10;            phoneNumber,&#10;            authKey&#10;        );&#10;&#10;        userDatabase.addUser(newUser);&#10;&#10;        StringBuilder response = new StringBuilder()&#10;            .append(&quot;Successfully created new user: &quot;).append(username)&#10;            .append(&quot; with host: &quot;).append(host)&#10;            .append(&quot;\nAuthentication type: &quot;).append(authType);&#10;&#10;        if (authKey != null) {&#10;            response.append(&quot;\nGenerated auth key (save this, it will only be shown once): \n&quot;)&#10;                   .append(authKey);&#10;        }&#10;        if (password != null) {&#10;            response.append(&quot;\nTemporary password (must be changed on first login): &quot;)&#10;                   .append(generateTempPassword());&#10;        }&#10;        if (phoneNumber != null) {&#10;            response.append(&quot;\nVerification code has been sent to: &quot;).append(phoneNumber);&#10;        }&#10;&#10;        return response.toString();&#10;    }&#10;&#10;    private String processDropCommand(String[] tokens) {&#10;        // Format: DROP CHICK 'username' ['reason']&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String username = tokens[2].replace(&quot;'&quot;, &quot;&quot;);&#10;        if (!userDatabase.getUsers().containsKey(username)) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        userDatabase.removeUser(username);&#10;        return &quot;Successfully dropped user: &quot; + username;&#10;    }&#10;&#10;    private String processGrantCommand(String[] tokens) {&#10;        // Format: GRANT CHICK username PERMISSION permission_type TO nest DURATION duration&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String username = tokens[2];&#10;        String permissionType = tokens[4];&#10;        String targetNest = tokens[6];&#10;        int duration = parseDuration(tokens[8]);&#10;&#10;        User user = userDatabase.getUser(username);&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        String[] currentPermissions = user.getPermissions();&#10;        String[] newPermissions = Arrays.copyOf(currentPermissions, currentPermissions.length + 1);&#10;        newPermissions[currentPermissions.length] = permissionType;&#10;&#10;        userDatabase.modifyPermissions(username, newPermissions);&#10;        return &quot;Successfully granted &quot; + permissionType + &quot; to &quot; + username;&#10;    }&#10;&#10;    private String processRevokeCommand(String[] tokens) {&#10;        // Format: REVOKE PERMISSION permission_type FROM 'username' DURATION duration&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String permissionType = tokens[2];&#10;        String username = tokens[4].replace(&quot;'&quot;, &quot;&quot;);&#10;        int duration = parseDuration(tokens[6]);&#10;&#10;        User user = userDatabase.getUser(username);&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User not found&quot;);&#10;        }&#10;&#10;        String[] currentPermissions = user.getPermissions();&#10;        String[] newPermissions = Arrays.stream(currentPermissions)&#10;            .filter(p -&gt; !p.equals(permissionType))&#10;            .toArray(String[]::new);&#10;&#10;        userDatabase.modifyPermissions(username, newPermissions);&#10;        return &quot;Successfully revoked &quot; + permissionType + &quot; from &quot; + username;&#10;    }&#10;&#10;    private String processCreateRoleCommand(String[] tokens) {&#10;        // Format: CREATE ROLE 'role_name' hierarchy_number&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        String roleName = tokens[2].replace(&quot;'&quot;, &quot;&quot;);&#10;        int hierarchyLevel = Integer.parseInt(tokens[3]);&#10;&#10;        // Add role to database (you might want to extend UserDatabase to handle roles)&#10;        return &quot;Successfully created role: &quot; + roleName + &quot; with hierarchy level &quot; + hierarchyLevel;&#10;    }&#10;&#10;    private String processDebugCommand(String[] tokens) {&#10;        // Format: INIT DEBUG USER [timeLength]&#10;        if (!hasAdminPermissions()) {&#10;            throw new SecurityException(&quot;FAULTYPERMISSIONEXCEPTION: Admin privileges required&quot;);&#10;        }&#10;&#10;        int timeLength = tokens.length &gt; 3 ? Integer.parseInt(tokens[3]) : 60; // Default 60 seconds&#10;        debugTimer.schedule(new TimerTask() {&#10;            @Override&#10;            public void run() {&#10;                System.out.println(&quot;Debug session ended for user: &quot; + currentUser.getUsername());&#10;            }&#10;        }, timeLength * 1000L);&#10;&#10;        return &quot;Debug mode initialized for &quot; + timeLength + &quot; seconds&quot;;&#10;    }&#10;&#10;    private boolean hasAdminPermissions() {&#10;        if (currentUser == null) return false;&#10;        return Arrays.asList(currentUser.getPermissions()).contains(&quot;ADMIN+&quot;);&#10;    }&#10;&#10;    private String generateTempPassword() {&#10;        // Generate a random 12-character password&#10;        String chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*&quot;;&#10;        StringBuilder password = new StringBuilder();&#10;        for (int i = 0; i &lt; 12; i++) {&#10;            password.append(chars.charAt((int) (Math.random() * chars.length())));&#10;        }&#10;        return password.toString();&#10;    }&#10;&#10;    private int parseDuration(String duration) {&#10;        try {&#10;            return Integer.parseInt(duration);&#10;        } catch (NumberFormatException e) {&#10;            throw new IllegalArgumentException(&quot;Invalid duration format. Expected a number.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Encryptor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Encryptor.java" />
              <option name="originalContent" value="import org.bouncycastle.crypto.generators.Argon2BytesGenerator;&#10;import org.bouncycastle.crypto.params.Argon2Parameters;&#10;import javax.crypto.*;&#10;import javax.crypto.spec.GCMParameterSpec;&#10;import javax.crypto.spec.SecretKeySpec;&#10;import java.nio.charset.StandardCharsets;&#10;import java.security.SecureRandom;&#10;import java.util.Base64;&#10;&#10;public class Encryptor {&#10;&#10;}" />
              <option name="updatedContent" value="import org.bouncycastle.crypto.generators.Argon2BytesGenerator;&#10;import org.bouncycastle.crypto.params.Argon2Parameters;&#10;import com.twilio.Twilio;&#10;import com.twilio.rest.api.v2010.account.Message;&#10;import com.twilio.type.PhoneNumber;&#10;import javax.crypto.*;&#10;import javax.crypto.spec.SecretKeySpec;&#10;import java.nio.charset.StandardCharsets;&#10;import java.security.*;&#10;import java.util.*;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;public class Encryptor {&#10;    // Twilio credentials (should be moved to secure configuration)&#10;    private static final String TWILIO_ACCOUNT_SID = &quot;your_account_sid&quot;;&#10;    private static final String TWILIO_AUTH_TOKEN = &quot;your_auth_token&quot;;&#10;    private static final String TWILIO_PHONE_NUMBER = &quot;your_twilio_phone&quot;;&#10;&#10;    // For storing pending 2FA verifications&#10;    private static final Map&lt;String, String&gt; pendingVerifications = new HashMap&lt;&gt;();&#10;    &#10;    public enum AuthType {&#10;        PASSWORD,&#10;        AUTH_KEY,&#10;        TWO_FACTOR&#10;    }&#10;&#10;    // Password handling&#10;    public String hashPassword(String password) {&#10;        try {&#10;            // Generate a random salt&#10;            byte[] salt = new byte[16];&#10;            SecureRandom random = new SecureRandom();&#10;            random.nextBytes(salt);&#10;&#10;            // Configure Argon2 parameters&#10;            Argon2Parameters.Builder builder = new Argon2Parameters.Builder(Argon2Parameters.ARGON2_id)&#10;                .withSalt(salt)&#10;                .withParallelism(4)&#10;                .withMemoryAsKB(65536) // 64MB&#10;                .withIterations(3);&#10;&#10;            // Generate the hash&#10;            Argon2BytesGenerator generator = new Argon2BytesGenerator();&#10;            generator.init(builder.build());&#10;            byte[] hash = new byte[32];&#10;            generator.generateBytes(password.getBytes(StandardCharsets.UTF_8), hash);&#10;&#10;            // Combine salt and hash&#10;            byte[] combined = new byte[salt.length + hash.length];&#10;            System.arraycopy(salt, 0, combined, 0, salt.length);&#10;            System.arraycopy(hash, 0, combined, salt.length, hash.length);&#10;&#10;            return Base64.getEncoder().encodeToString(combined);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error hashing password&quot;, e);&#10;        }&#10;    }&#10;&#10;    public boolean verifyPassword(String password, String storedHash) {&#10;        try {&#10;            byte[] combined = Base64.getDecoder().decode(storedHash);&#10;            byte[] salt = Arrays.copyOfRange(combined, 0, 16);&#10;            byte[] hash = Arrays.copyOfRange(combined, 16, combined.length);&#10;&#10;            Argon2Parameters.Builder builder = new Argon2Parameters.Builder(Argon2Parameters.ARGON2_id)&#10;                .withSalt(salt)&#10;                .withParallelism(4)&#10;                .withMemoryAsKB(65536)&#10;                .withIterations(3);&#10;&#10;            Argon2BytesGenerator generator = new Argon2BytesGenerator();&#10;            generator.init(builder.build());&#10;            byte[] checkHash = new byte[32];&#10;            generator.generateBytes(password.getBytes(StandardCharsets.UTF_8), checkHash);&#10;&#10;            return Arrays.equals(hash, checkHash);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error verifying password&quot;, e);&#10;        }&#10;    }&#10;&#10;    // Auth key handling&#10;    public String generateAuthKey() {&#10;        try {&#10;            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);&#10;            keyGen.initialize(2048);&#10;            KeyPair pair = keyGen.generateKeyPair();&#10;            return Base64.getEncoder().encodeToString(pair.getPrivate().getEncoded());&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error generating auth key&quot;, e);&#10;        }&#10;    }&#10;&#10;    public boolean verifyAuthKey(String providedKey, String storedKey) {&#10;        return providedKey.equals(storedKey);&#10;    }&#10;&#10;    // 2FA handling&#10;    public String initiate2FA(String phoneNumber) {&#10;        try {&#10;            // Initialize Twilio&#10;            Twilio.init(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);&#10;&#10;            // Generate a 6-digit code&#10;            String verificationCode = generateVerificationCode();&#10;            &#10;            // Store the code&#10;            pendingVerifications.put(phoneNumber, verificationCode);&#10;&#10;            // Send SMS&#10;            Message message = Message.creator(&#10;                new PhoneNumber(phoneNumber),&#10;                new PhoneNumber(TWILIO_PHONE_NUMBER),&#10;                &quot;Your BDL verification code is: &quot; + verificationCode&#10;            ).create();&#10;&#10;            return verificationCode;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Error initiating 2FA&quot;, e);&#10;        }&#10;    }&#10;&#10;    public boolean verify2FACode(String phoneNumber, String code) {&#10;        String storedCode = pendingVerifications.get(phoneNumber);&#10;        if (storedCode != null &amp;&amp; storedCode.equals(code)) {&#10;            pendingVerifications.remove(phoneNumber); // Clean up after successful verification&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private String generateVerificationCode() {&#10;        SecureRandom random = new SecureRandom();&#10;        StringBuilder code = new StringBuilder();&#10;        for (int i = 0; i &lt; 6; i++) {&#10;            code.append(random.nextInt(10));&#10;        }&#10;        return code.toString();&#10;    }&#10;&#10;    // Utility method to determine if a phone number is valid&#10;    public boolean isValidPhoneNumber(String phoneNumber) {&#10;        // Basic validation - should be enhanced based on requirements&#10;        return phoneNumber.matches(&quot;\\+?\\d{10,15}&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/User.java" />
              <option name="originalContent" value="import lombok.Getter;&#10;import lombok.Setter;&#10;public class User {&#10;&#10;    @Getter @Setter&#10;    protected String username;&#10;&#10;    @Getter @Setter&#10;    protected String password;&#10;&#10;    @Getter @Setter&#10;    protected String host;&#10;&#10;    @Getter @Setter&#10;    protected String[] permissions;&#10;&#10;    @Getter @Setter&#10;    protected boolean lock;&#10;&#10;    @Getter @Setter&#10;    protected String creationDate;&#10;&#10;    @Getter @Setter&#10;    protected String creator_id;&#10;&#10;&#10;    public User(String username, String password, String host, String[] permissions, boolean lock, String creationDate, String creator_id) {&#10;        this.username = username;&#10;        this.password = password;&#10;        this.host = host;&#10;        this.permissions = permissions;&#10;        this.lock = lock;&#10;        this.creationDate = creationDate;&#10;        this.creator_id = creator_id;&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;public class User {&#10;    @Getter @Setter&#10;    protected String username;&#10;&#10;    @Getter @Setter&#10;    protected String password;&#10;&#10;    @Getter @Setter&#10;    protected String host;&#10;&#10;    @Getter @Setter&#10;    protected String[] permissions;&#10;&#10;    @Getter @Setter&#10;    protected boolean lock;&#10;&#10;    @Getter @Setter&#10;    protected String creationDate;&#10;&#10;    @Getter @Setter&#10;    protected String creator_id;&#10;&#10;    @Getter @Setter&#10;    protected String authType;&#10;&#10;    @Getter @Setter&#10;    protected String phoneNumber;  // For 2FA&#10;&#10;    @Getter @Setter&#10;    protected String authKey;      // For auth_key authentication&#10;&#10;    public User(String username, String password, String host, String[] permissions, &#10;                boolean lock, String creationDate, String creator_id, &#10;                String authType, String phoneNumber, String authKey) {&#10;        this.username = username;&#10;        this.password = password;&#10;        this.host = host;&#10;        this.permissions = permissions;&#10;        this.lock = lock;&#10;        this.creationDate = creationDate;&#10;        this.creator_id = creator_id;&#10;        this.authType = authType;&#10;        this.phoneNumber = phoneNumber;&#10;        this.authKey = authKey;&#10;    }&#10;&#10;    // Constructor for backward compatibility&#10;    public User(String username, String password, String host, String[] permissions, &#10;                boolean lock, String creationDate, String creator_id) {&#10;        this(username, password, host, permissions, lock, creationDate, &#10;             creator_id, &quot;password&quot;, null, null);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>